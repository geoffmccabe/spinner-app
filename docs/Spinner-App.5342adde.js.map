{"mappings":"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","sources":["<anon>","src/main.js"],"sourcesContent":["var $2b6e161c9edcf319$exports = {};\n// src/main.js\n// Attempt to import the UMD build of webp-wasm.\n// Parcel should be able to resolve this from node_modules if 'webp-wasm' is listed in dependencies.\n// The 'WebP' global might also be available if the UMD module sets it up.\n// We'll try to use the global WebP object as that's what UMD scripts typically provide.\n// If you had `import WebPEncoder from 'webp-wasm/dist/legacy/umd/index.js';` Parcel might handle it,\n// but relying on the global `WebP` is safer for a direct UMD script inclusion.\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    const MAX_OBJECTS = 6;\n    let objects = [];\n    let activeObjectIndex = 0;\n    let animationFrameId = null;\n    let globalLastFrameTimestamp = 0;\n    const canvas = document.getElementById('spinnerCanvas');\n    const ctx = canvas.getContext('2d');\n    const canvasMessage = document.getElementById('canvasMessage');\n    const objectSelectorContainer = document.getElementById('objectSelectorContainer');\n    const imageUpload = document.getElementById('imageUpload');\n    const removeImageButton = document.getElementById('removeImageButton');\n    const degreesPerFrameInput = document.getElementById('degreesPerFrame');\n    const finalVerticalSizeInput = document.getElementById('finalVerticalSize');\n    const opacityInput = document.getElementById('opacity');\n    const totalExportFramesInput = document.getElementById('totalExportFrames');\n    const frameTimeInput = document.getElementById('frameTime');\n    const webpCompressionInput = document.getElementById('webpCompression');\n    const exportButton = document.getElementById('exportButton');\n    const loadingIndicator = document.getElementById('loadingIndicator');\n    const exportMessage = document.getElementById('exportMessage');\n    // Check if webp-wasm is loaded (it should be if webp-wasm.js is present and correct)\n    // The library should expose a global `WebP` object.\n    if (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined') {\n        console.error(\"WebP-WASM library (WebP.Encoder) not loaded correctly. Animated WebP export will not work. Ensure 'webp-wasm.js' is present and correct in the same directory as index.html if using local file, or that the library is correctly installed via npm and bundled by Parcel.\");\n        exportMessage.innerHTML = \"<span class='text-red-500 font-bold'>CRITICAL ERROR: WebP encoding library not found or failed to load. Animated export is disabled.</span><br><small>If using local setup, ensure 'webp-wasm.js' is correctly placed. If using npm, ensure 'webp-wasm' is installed and Parcel is bundling correctly.</small>\";\n        if (exportButton) exportButton.disabled = true;\n    }\n    function initializeObjectsAndUI() {\n        objects = [];\n        for(let i = 0; i < MAX_OBJECTS; i++)objects.push({\n            id: i,\n            name: `Object ${i + 1}`,\n            image: null,\n            fileName: null,\n            originalWidth: 0,\n            originalHeight: 0,\n            settings: {\n                degreesPerFrame: 10,\n                finalVerticalSize: null,\n                opacity: 100\n            },\n            livePreviewRotationAngle: 0\n        });\n        createObjectSelectorButtons();\n        setActiveObject(0);\n    }\n    function createObjectSelectorButtons() {\n        objectSelectorContainer.innerHTML = '';\n        objects.forEach((obj)=>{\n            const container = document.createElement('div');\n            container.classList.add('object-button-container');\n            const button = document.createElement('button');\n            button.textContent = obj.name + (obj.image ? \" \\u2713\" : '');\n            button.classList.add('object-button', 'p-2', 'border', 'border-slate-300', 'rounded-md', 'text-sm');\n            if (obj.image) button.classList.add('font-semibold');\n            button.addEventListener('click', ()=>setActiveObject(obj.id));\n            const fileNameSpan = document.createElement('span');\n            fileNameSpan.classList.add('object-file-name');\n            fileNameSpan.textContent = obj.fileName || '(empty)';\n            container.appendChild(button);\n            container.appendChild(fileNameSpan);\n            objectSelectorContainer.appendChild(container);\n        });\n        updateActiveButtonUI();\n    }\n    function updateActiveButtonUI() {\n        const buttons = objectSelectorContainer.querySelectorAll('.object-button');\n        const fileNameSpans = objectSelectorContainer.querySelectorAll('.object-file-name');\n        buttons.forEach((btn, index)=>{\n            btn.classList.toggle('active', index === activeObjectIndex);\n            const obj = objects[index];\n            btn.textContent = obj.name + (obj.image ? \" \\u2713\" : '');\n            if (obj.image) btn.classList.add('font-semibold');\n            else btn.classList.remove('font-semibold');\n            if (fileNameSpans[index]) fileNameSpans[index].textContent = obj.fileName || '(empty)';\n        });\n    }\n    function setActiveObject(index) {\n        activeObjectIndex = index;\n        loadSettingsForActiveObject();\n        updateActiveButtonUI();\n        removeImageButton.disabled = !objects[activeObjectIndex].image;\n        exportButton.disabled = !objects.some((obj)=>obj.image) || typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined';\n        drawLivePreview();\n    }\n    function loadSettingsForActiveObject() {\n        const currentObject = objects[activeObjectIndex];\n        degreesPerFrameInput.value = currentObject.settings.degreesPerFrame;\n        finalVerticalSizeInput.value = currentObject.settings.finalVerticalSize || '';\n        opacityInput.value = currentObject.settings.opacity;\n    }\n    function saveSettingForActiveObject(inputElement) {\n        const obj = objects[activeObjectIndex];\n        if (!obj) return;\n        const settingKey = inputElement.id;\n        let value = inputElement.value;\n        if (inputElement.type === 'number') {\n            value = parseFloat(value);\n            if (isNaN(value)) {\n                if (settingKey === 'finalVerticalSize') value = null;\n                else if (settingKey === 'degreesPerFrame') value = 0;\n                else if (settingKey === 'opacity') value = 100;\n            }\n        }\n        if (settingKey === 'degreesPerFrame') obj.settings.degreesPerFrame = value;\n        else if (settingKey === 'finalVerticalSize') obj.settings.finalVerticalSize = value === null || isNaN(parseFloat(value)) ? obj.image ? obj.originalHeight : null : parseFloat(value);\n        else if (settingKey === 'opacity') obj.settings.opacity = Math.max(0, Math.min(100, parseFloat(value) || 100));\n        if (settingKey === 'degreesPerFrame' || settingKey === 'opacity') startOrUpdateAnimationLoop();\n        if (settingKey === 'finalVerticalSize' || settingKey === 'opacity') drawLivePreview();\n    }\n    imageUpload.addEventListener('change', (event)=>{\n        const file = event.target.files[0];\n        const currentObject = objects[activeObjectIndex];\n        if (!currentObject || !file) return;\n        currentObject.fileName = file.name;\n        if (file.type === \"image/png\" || file.type === \"image/gif\" || file.type === \"image/webp\" || file.type === \"image/jpeg\") {\n            const reader = new FileReader();\n            reader.onload = (e)=>{\n                currentObject.image = new Image();\n                currentObject.image.onload = ()=>{\n                    currentObject.originalWidth = currentObject.image.width;\n                    currentObject.originalHeight = currentObject.image.height;\n                    if (currentObject.settings.finalVerticalSize === null || currentObject.settings.finalVerticalSize === '') {\n                        currentObject.settings.finalVerticalSize = currentObject.originalHeight;\n                        if (activeObjectIndex === objects.findIndex((o)=>o === currentObject)) finalVerticalSizeInput.value = currentObject.settings.finalVerticalSize;\n                    }\n                    canvasMessage.textContent = `${currentObject.name} ('${currentObject.fileName}') loaded.`;\n                    currentObject.livePreviewRotationAngle = 0;\n                    globalLastFrameTimestamp = performance.now();\n                    startOrUpdateAnimationLoop();\n                    createObjectSelectorButtons();\n                    removeImageButton.disabled = false;\n                    exportButton.disabled = typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined';\n                };\n                currentObject.image.onerror = ()=>{\n                    currentObject.fileName = null;\n                    canvasMessage.textContent = `Error loading ${file.name}.`;\n                    createObjectSelectorButtons();\n                };\n                currentObject.image.src = e.target.result;\n            };\n            reader.readAsDataURL(file);\n        } else {\n            currentObject.fileName = null;\n            canvasMessage.textContent = `Unsupported file type for ${file.name}.`;\n            createObjectSelectorButtons();\n        }\n        imageUpload.value = '';\n    });\n    removeImageButton.addEventListener('click', ()=>{\n        const obj = objects[activeObjectIndex];\n        if (obj && obj.image) {\n            obj.image = null;\n            obj.fileName = null;\n            obj.originalWidth = 0;\n            obj.originalHeight = 0;\n            obj.livePreviewRotationAngle = 0;\n            createObjectSelectorButtons();\n            removeImageButton.disabled = true;\n            exportButton.disabled = !objects.some((o)=>o.image) || typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined';\n            drawLivePreview();\n            canvasMessage.textContent = `${obj.name} image removed.`;\n        }\n    });\n    function drawLivePreview() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        let hasAnyImage = false;\n        for(let i = MAX_OBJECTS - 1; i >= 0; i--){\n            const obj = objects[i];\n            if (!obj.image) continue;\n            hasAnyImage = true;\n            let previewHeight = obj.settings.finalVerticalSize || obj.originalHeight;\n            if (previewHeight <= 0) previewHeight = obj.originalHeight;\n            const aspectRatio = obj.originalWidth > 0 && obj.originalHeight > 0 ? obj.originalWidth / obj.originalHeight : 1;\n            let previewWidth = previewHeight * aspectRatio;\n            const maxDim = 1580;\n            if (previewWidth > maxDim || previewHeight > maxDim) {\n                if (aspectRatio >= 1) {\n                    previewWidth = maxDim;\n                    previewHeight = maxDim / aspectRatio;\n                } else {\n                    previewHeight = maxDim;\n                    previewWidth = maxDim * aspectRatio;\n                }\n            }\n            ctx.save();\n            ctx.globalAlpha = obj.settings.opacity / 100;\n            if (i === activeObjectIndex) {\n                const boxX = (canvas.width - previewWidth) / 2;\n                const boxY = (canvas.height - previewHeight) / 2;\n                const tempAlpha = ctx.globalAlpha; // Save current alpha for image\n                ctx.globalAlpha = 1; // Bounding box should be fully opaque\n                ctx.strokeStyle = '#CCCCCC';\n                ctx.lineWidth = 2;\n                ctx.strokeRect(boxX, boxY, previewWidth, previewHeight);\n                ctx.globalAlpha = tempAlpha; // Restore alpha for drawing the image\n            }\n            ctx.translate(canvas.width / 2, canvas.height / 2);\n            ctx.rotate(obj.livePreviewRotationAngle * Math.PI / 180);\n            ctx.drawImage(obj.image, -previewWidth / 2, -previewHeight / 2, previewWidth, previewHeight);\n            ctx.restore(); // Restores globalAlpha and other transformations\n        }\n        ctx.globalAlpha = 1.0; // Ensure globalAlpha is reset after drawing all objects\n        if (!hasAnyImage && activeObjectIndex >= 0) canvasMessage.textContent = `${objects[activeObjectIndex].name} is empty. Upload an image.`;\n        else if (hasAnyImage && activeObjectIndex >= 0) canvasMessage.textContent = `Previewing. Settings for ${objects[activeObjectIndex].name}.`;\n        else canvasMessage.textContent = \"Select an object and upload an image.\";\n    }\n    function animationLoop(timestamp) {\n        const desiredFrameTime = parseFloat(frameTimeInput.value) || 83.3;\n        const elapsed = timestamp - globalLastFrameTimestamp;\n        if (elapsed >= desiredFrameTime) {\n            globalLastFrameTimestamp = timestamp - elapsed % desiredFrameTime;\n            let needsRedraw = false;\n            objects.forEach((obj)=>{\n                if (obj.image) {\n                    const degreesPerStep = obj.settings.degreesPerFrame || 0;\n                    if (degreesPerStep !== 0) {\n                        obj.livePreviewRotationAngle = obj.livePreviewRotationAngle + degreesPerStep;\n                        // Normalize angle to be between 0 and 359.99...\n                        while(obj.livePreviewRotationAngle >= 360)obj.livePreviewRotationAngle -= 360;\n                        while(obj.livePreviewRotationAngle < 0)obj.livePreviewRotationAngle += 360;\n                        needsRedraw = true;\n                    } else if (obj.livePreviewRotationAngle !== 0 && degreesPerStep === 0) needsRedraw = true;\n                }\n            });\n            if (needsRedraw || objects.some((obj)=>obj.image && obj.settings.degreesPerFrame === 0)) drawLivePreview();\n        }\n        if (objects.some((o)=>o.image)) animationFrameId = requestAnimationFrame(animationLoop);\n        else {\n            animationFrameId = null;\n            drawLivePreview(); // Clear canvas if no images\n        }\n    }\n    function startOrUpdateAnimationLoop() {\n        if (animationFrameId) {\n            cancelAnimationFrame(animationFrameId);\n            animationFrameId = null;\n        }\n        if (objects.some((obj)=>obj.image)) {\n            globalLastFrameTimestamp = performance.now();\n            animationFrameId = requestAnimationFrame(animationLoop);\n        } else drawLivePreview(); // Clear canvas if no images\n    }\n    // Event listeners for per-object settings\n    [\n        degreesPerFrameInput,\n        finalVerticalSizeInput,\n        opacityInput\n    ].forEach((input)=>{\n        input.addEventListener('input', ()=>saveSettingForActiveObject(input));\n    });\n    // Event listeners for global/composite settings\n    [\n        totalExportFramesInput,\n        frameTimeInput,\n        webpCompressionInput\n    ].forEach((input)=>{\n        input.addEventListener('input', ()=>{\n            if (input === frameTimeInput && objects.some((obj)=>obj.image)) startOrUpdateAnimationLoop(); // Frame time affects live preview speed\n        // totalExportFrames & webpCompression only affect export, no immediate redraw needed.\n        });\n    });\n    exportButton.addEventListener('click', async ()=>{\n        // Use the globally available WebP object from the UMD script\n        if (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined') {\n            exportMessage.innerHTML = \"<span class='text-red-500 font-bold'>CRITICAL ERROR: WebP encoding library ('webp-wasm.js' if local, or npm install) not found or failed to load. Animated export is disabled.</span>\";\n            console.error(\"WebP or WebP.Encoder is undefined. Library might not have initialized correctly.\");\n            return;\n        }\n        const activeImages = objects.filter((obj)=>obj.image);\n        if (activeImages.length === 0) {\n            exportMessage.textContent = \"No images to export.\";\n            return;\n        }\n        exportMessage.textContent = \"Preparing animated WebP export...\";\n        loadingIndicator.classList.remove('hidden');\n        exportButton.disabled = true;\n        await new Promise((resolve)=>setTimeout(resolve, 100)); // Allow UI to update\n        try {\n            const compositeTotalFrames = parseInt(totalExportFramesInput.value) || 36;\n            const compositeFrameTimeMs = parseFloat(frameTimeInput.value) || 83.3;\n            const compositeWebpQuality = parseInt(webpCompressionInput.value) || 75;\n            if (compositeTotalFrames < 1) {\n                exportMessage.textContent = \"Total export frames must be at least 1.\";\n                loadingIndicator.classList.add('hidden');\n                exportButton.disabled = false;\n                return;\n            }\n            const offscreenCanvas = document.createElement('canvas');\n            // The offscreen canvas for export should be the actual 1600x1600 working resolution\n            offscreenCanvas.width = 1600;\n            offscreenCanvas.height = 1600;\n            const offCtx = offscreenCanvas.getContext('2d');\n            // Initialize WebP Encoder from the global WebP object\n            const webPEncoder = new WebP.Encoder(offscreenCanvas.width, offscreenCanvas.height, {\n                quality: compositeWebpQuality,\n                lossless: false // Set to true for lossless if preferred, false for better compression (lossy)\n            });\n            webPEncoder.setLoops(0); // 0 for infinite loop\n            for(let i = 0; i < compositeTotalFrames; i++){\n                offCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n                // Draw all active objects in REVERSE order for correct layering in export\n                // (Object 0 is top layer, drawn last)\n                for(let k = MAX_OBJECTS - 1; k >= 0; k--){\n                    const obj = objects[k];\n                    if (!obj.image) continue;\n                    const currentRotationDegrees = i * (obj.settings.degreesPerFrame || 0);\n                    let exportObjHeight = obj.settings.finalVerticalSize || obj.originalHeight;\n                    if (exportObjHeight <= 0) exportObjHeight = obj.originalHeight;\n                    const aspectRatio = obj.originalWidth > 0 && obj.originalHeight > 0 ? obj.originalWidth / obj.originalHeight : 1;\n                    let exportObjWidth = exportObjHeight * aspectRatio;\n                    // Scale object to fit within the 1600x1600 export canvas if needed, maintaining aspect ratio\n                    const maxDimExport = 1580; // Similar to preview, with some padding\n                    if (exportObjWidth > maxDimExport || exportObjHeight > maxDimExport) {\n                        if (aspectRatio >= 1) {\n                            exportObjWidth = maxDimExport;\n                            exportObjHeight = maxDimExport / aspectRatio;\n                        } else {\n                            exportObjHeight = maxDimExport;\n                            exportObjWidth = maxDimExport * aspectRatio;\n                        }\n                    }\n                    offCtx.save();\n                    offCtx.globalAlpha = obj.settings.opacity / 100;\n                    offCtx.translate(offscreenCanvas.width / 2, offscreenCanvas.height / 2); // Center in 1600x1600\n                    offCtx.rotate(currentRotationDegrees * Math.PI / 180);\n                    offCtx.drawImage(obj.image, -exportObjWidth / 2, -exportObjHeight / 2, exportObjWidth, exportObjHeight);\n                    offCtx.restore();\n                }\n                offCtx.globalAlpha = 1.0; // Reset globalAlpha for the context before adding frame\n                // Add frame to encoder\n                webPEncoder.addFrame(offCtx, compositeFrameTimeMs);\n                exportMessage.textContent = `Encoding frame ${i + 1} of ${compositeTotalFrames}...`;\n                if (i % 5 === 0 && i > 0) await new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n            exportMessage.textContent = \"Finalizing WebP animation...\";\n            await new Promise((resolve)=>setTimeout(resolve, 50)); // Short delay for UI\n            const webpData = webPEncoder.finish(); // Get Uint8Array\n            webPEncoder.release(); // IMPORTANT: Release encoder resources\n            const blob = new Blob([\n                webpData\n            ], {\n                type: 'image/webp'\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `spinner_animation_${Date.now()}.webp`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n            exportMessage.innerHTML = `Animated WebP exported successfully! (${compositeTotalFrames} frames)`;\n            exportMessage.className = \"text-sm text-center text-green-700 mt-2 font-semibold\";\n        } catch (error) {\n            console.error(\"Error during WebP export:\", error);\n            exportMessage.textContent = \"Error during WebP export. Check console.\";\n            exportMessage.className = \"text-sm text-center text-red-600 mt-2\";\n        } finally{\n            loadingIndicator.classList.add('hidden');\n            // Re-enable button only if library is loaded and images exist\n            exportButton.disabled = !objects.some((o)=>o.image) || typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined';\n        }\n    });\n    // Initialize the application\n    initializeObjectsAndUI();\n    // Initially disable export button until an image is loaded and library is confirmed\n    exportButton.disabled = true;\n});\n\n\n//# sourceMappingURL=Spinner-App.5342adde.js.map\n","// src/main.js\n\n// Attempt to import the UMD build of webp-wasm.\n// Parcel should be able to resolve this from node_modules if 'webp-wasm' is listed in dependencies.\n// The 'WebP' global might also be available if the UMD module sets it up.\n// We'll try to use the global WebP object as that's what UMD scripts typically provide.\n// If you had `import WebPEncoder from 'webp-wasm/dist/legacy/umd/index.js';` Parcel might handle it,\n// but relying on the global `WebP` is safer for a direct UMD script inclusion.\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const MAX_OBJECTS = 6;\n    let objects = [];\n    let activeObjectIndex = 0;\n    let animationFrameId = null;\n    let globalLastFrameTimestamp = 0;\n\n    const canvas = document.getElementById('spinnerCanvas');\n    const ctx = canvas.getContext('2d');\n    const canvasMessage = document.getElementById('canvasMessage');\n    const objectSelectorContainer = document.getElementById('objectSelectorContainer');\n    const imageUpload = document.getElementById('imageUpload');\n    const removeImageButton = document.getElementById('removeImageButton');\n\n    const degreesPerFrameInput = document.getElementById('degreesPerFrame');\n    const finalVerticalSizeInput = document.getElementById('finalVerticalSize'); \n    const opacityInput = document.getElementById('opacity');\n    const totalExportFramesInput = document.getElementById('totalExportFrames'); \n    const frameTimeInput = document.getElementById('frameTime'); \n    const webpCompressionInput = document.getElementById('webpCompression');\n    const exportButton = document.getElementById('exportButton');\n    const loadingIndicator = document.getElementById('loadingIndicator');\n    const exportMessage = document.getElementById('exportMessage');\n\n    // Check if webp-wasm is loaded (it should be if webp-wasm.js is present and correct)\n    // The library should expose a global `WebP` object.\n    if (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined') {\n        console.error(\"WebP-WASM library (WebP.Encoder) not loaded correctly. Animated WebP export will not work. Ensure 'webp-wasm.js' is present and correct in the same directory as index.html if using local file, or that the library is correctly installed via npm and bundled by Parcel.\");\n        exportMessage.innerHTML = \"<span class='text-red-500 font-bold'>CRITICAL ERROR: WebP encoding library not found or failed to load. Animated export is disabled.</span><br><small>If using local setup, ensure 'webp-wasm.js' is correctly placed. If using npm, ensure 'webp-wasm' is installed and Parcel is bundling correctly.</small>\";\n        if(exportButton) exportButton.disabled = true;\n    }\n\n\n    function initializeObjectsAndUI() {\n        objects = [];\n        for (let i = 0; i < MAX_OBJECTS; i++) {\n            objects.push({\n                id: i,\n                name: `Object ${i + 1}`,\n                image: null,\n                fileName: null, \n                originalWidth: 0,\n                originalHeight: 0,\n                settings: {\n                    degreesPerFrame: 10,\n                    finalVerticalSize: null,\n                    opacity: 100, \n                },\n                livePreviewRotationAngle: 0,\n            });\n        }\n        createObjectSelectorButtons();\n        setActiveObject(0); \n    }\n\n    function createObjectSelectorButtons() {\n        objectSelectorContainer.innerHTML = ''; \n        objects.forEach(obj => {\n            const container = document.createElement('div');\n            container.classList.add('object-button-container');\n            const button = document.createElement('button');\n            button.textContent = obj.name + (obj.image ? ' ✓' : '');\n            button.classList.add('object-button', 'p-2', 'border', 'border-slate-300', 'rounded-md', 'text-sm');\n            if (obj.image) button.classList.add('font-semibold');\n            button.addEventListener('click', () => setActiveObject(obj.id));\n            const fileNameSpan = document.createElement('span');\n            fileNameSpan.classList.add('object-file-name');\n            fileNameSpan.textContent = obj.fileName || '(empty)';\n            container.appendChild(button);\n            container.appendChild(fileNameSpan);\n            objectSelectorContainer.appendChild(container);\n        });\n        updateActiveButtonUI();\n    }\n    \n    function updateActiveButtonUI() {\n        const buttons = objectSelectorContainer.querySelectorAll('.object-button');\n        const fileNameSpans = objectSelectorContainer.querySelectorAll('.object-file-name');\n        buttons.forEach((btn, index) => {\n            btn.classList.toggle('active', index === activeObjectIndex);\n            const obj = objects[index];\n            btn.textContent = obj.name + (obj.image ? ' ✓' : '');\n            if (obj.image) btn.classList.add('font-semibold'); else btn.classList.remove('font-semibold');\n            if (fileNameSpans[index]) {\n                fileNameSpans[index].textContent = obj.fileName || '(empty)';\n            }\n        });\n    }\n\n    function setActiveObject(index) {\n        activeObjectIndex = index;\n        loadSettingsForActiveObject();\n        updateActiveButtonUI();\n        removeImageButton.disabled = !objects[activeObjectIndex].image;\n        exportButton.disabled = !objects.some(obj => obj.image) || (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined'); \n        drawLivePreview(); \n    }\n\n    function loadSettingsForActiveObject() {\n        const currentObject = objects[activeObjectIndex];\n        degreesPerFrameInput.value = currentObject.settings.degreesPerFrame;\n        finalVerticalSizeInput.value = currentObject.settings.finalVerticalSize || '';\n        opacityInput.value = currentObject.settings.opacity;\n    }\n\n    function saveSettingForActiveObject(inputElement) {\n        const obj = objects[activeObjectIndex];\n        if (!obj) return;\n        const settingKey = inputElement.id; \n        let value = inputElement.value;\n\n        if (inputElement.type === 'number') {\n            value = parseFloat(value);\n            if (isNaN(value)) { \n                if (settingKey === 'finalVerticalSize') value = null;\n                else if (settingKey === 'degreesPerFrame') value = 0; \n                else if (settingKey === 'opacity') value = 100;\n            }\n        }\n        \n        if (settingKey === 'degreesPerFrame') obj.settings.degreesPerFrame = value;\n        else if (settingKey === 'finalVerticalSize') {\n            obj.settings.finalVerticalSize = value === null || isNaN(parseFloat(value)) ? (obj.image ? obj.originalHeight : null) : parseFloat(value);\n        } else if (settingKey === 'opacity') {\n            obj.settings.opacity = Math.max(0, Math.min(100, parseFloat(value) || 100)); \n        }\n\n        if (settingKey === 'degreesPerFrame' || settingKey === 'opacity') {\n            startOrUpdateAnimationLoop(); \n        }\n        if (settingKey === 'finalVerticalSize' || settingKey === 'opacity') {\n            drawLivePreview(); \n        }\n    }\n\n    imageUpload.addEventListener('change', (event) => {\n        const file = event.target.files[0];\n        const currentObject = objects[activeObjectIndex];\n        if (!currentObject || !file) return;\n        currentObject.fileName = file.name; \n\n        if (file.type === \"image/png\" || file.type === \"image/gif\" || file.type === \"image/webp\" || file.type === \"image/jpeg\") {\n            const reader = new FileReader();\n            reader.onload = (e) => {\n                currentObject.image = new Image();\n                currentObject.image.onload = () => {\n                    currentObject.originalWidth = currentObject.image.width;\n                    currentObject.originalHeight = currentObject.image.height;\n                    if (currentObject.settings.finalVerticalSize === null || currentObject.settings.finalVerticalSize === '') {\n                        currentObject.settings.finalVerticalSize = currentObject.originalHeight;\n                        if (activeObjectIndex === objects.findIndex(o => o === currentObject)) {\n                             finalVerticalSizeInput.value = currentObject.settings.finalVerticalSize;\n                        }\n                    }\n                    canvasMessage.textContent = `${currentObject.name} ('${currentObject.fileName}') loaded.`;\n                    currentObject.livePreviewRotationAngle = 0; \n                    globalLastFrameTimestamp = performance.now(); \n                    startOrUpdateAnimationLoop(); \n                    createObjectSelectorButtons(); \n                    removeImageButton.disabled = false;\n                    exportButton.disabled = (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined'); \n                };\n                currentObject.image.onerror = () => { currentObject.fileName = null; canvasMessage.textContent = `Error loading ${file.name}.`; createObjectSelectorButtons();};\n                currentObject.image.src = e.target.result;\n            };\n            reader.readAsDataURL(file);\n        } else { currentObject.fileName = null; canvasMessage.textContent = `Unsupported file type for ${file.name}.`; createObjectSelectorButtons(); }\n         imageUpload.value = ''; \n    });\n\n    removeImageButton.addEventListener('click', () => {\n        const obj = objects[activeObjectIndex];\n        if (obj && obj.image) {\n            obj.image = null;\n            obj.fileName = null;\n            obj.originalWidth = 0;\n            obj.originalHeight = 0;\n            obj.livePreviewRotationAngle = 0;\n            createObjectSelectorButtons(); \n            removeImageButton.disabled = true;\n            exportButton.disabled = !objects.some(o => o.image) || (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined'); \n            drawLivePreview();\n            canvasMessage.textContent = `${obj.name} image removed.`;\n        }\n    });\n    \n    function drawLivePreview() {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        let hasAnyImage = false;\n        for (let i = MAX_OBJECTS - 1; i >= 0; i--) { // Draw from last to first for correct layering (obj 0 is top)\n            const obj = objects[i];\n            if (!obj.image) continue;\n            hasAnyImage = true;\n            let previewHeight = obj.settings.finalVerticalSize || obj.originalHeight;\n            if (previewHeight <= 0) previewHeight = obj.originalHeight;\n            const aspectRatio = obj.originalWidth > 0 && obj.originalHeight > 0 ? obj.originalWidth / obj.originalHeight : 1;\n            let previewWidth = previewHeight * aspectRatio;\n            const maxDim = 1580; \n            if (previewWidth > maxDim || previewHeight > maxDim) {\n                if (aspectRatio >= 1) { \n                    previewWidth = maxDim; previewHeight = maxDim / aspectRatio;\n                } else { \n                    previewHeight = maxDim; previewWidth = maxDim * aspectRatio;\n                }\n            }\n            ctx.save(); \n            ctx.globalAlpha = (obj.settings.opacity / 100);\n            if (i === activeObjectIndex) { // Draw bounding box only for the active object\n                const boxX = (canvas.width - previewWidth) / 2;\n                const boxY = (canvas.height - previewHeight) / 2;\n                const tempAlpha = ctx.globalAlpha; // Save current alpha for image\n                ctx.globalAlpha = 1; // Bounding box should be fully opaque\n                ctx.strokeStyle = '#CCCCCC'; \n                ctx.lineWidth = 2;          \n                ctx.strokeRect(boxX, boxY, previewWidth, previewHeight);\n                ctx.globalAlpha = tempAlpha; // Restore alpha for drawing the image\n            }\n            ctx.translate(canvas.width / 2, canvas.height / 2);\n            ctx.rotate(obj.livePreviewRotationAngle * Math.PI / 180); \n            ctx.drawImage(obj.image, -previewWidth / 2, -previewHeight / 2, previewWidth, previewHeight);\n            ctx.restore(); // Restores globalAlpha and other transformations\n        }\n        ctx.globalAlpha = 1.0; // Ensure globalAlpha is reset after drawing all objects\n\n        if (!hasAnyImage && activeObjectIndex >=0) canvasMessage.textContent = `${objects[activeObjectIndex].name} is empty. Upload an image.`;\n        else if (hasAnyImage && activeObjectIndex >=0) canvasMessage.textContent = `Previewing. Settings for ${objects[activeObjectIndex].name}.`;\n        else canvasMessage.textContent = \"Select an object and upload an image.\";\n    }\n    \n    function animationLoop(timestamp) {\n        const desiredFrameTime = parseFloat(frameTimeInput.value) || 83.3; \n        const elapsed = timestamp - globalLastFrameTimestamp;\n\n        if (elapsed >= desiredFrameTime) {\n            globalLastFrameTimestamp = timestamp - (elapsed % desiredFrameTime); \n            let needsRedraw = false;\n            objects.forEach(obj => {\n                if (obj.image) {\n                    const degreesPerStep = obj.settings.degreesPerFrame || 0; \n                    if (degreesPerStep !== 0) { \n                       obj.livePreviewRotationAngle = (obj.livePreviewRotationAngle + degreesPerStep);\n                       // Normalize angle to be between 0 and 359.99...\n                       while (obj.livePreviewRotationAngle >= 360) obj.livePreviewRotationAngle -= 360;\n                       while (obj.livePreviewRotationAngle < 0) obj.livePreviewRotationAngle += 360;\n                       needsRedraw = true;\n                    } else if (obj.livePreviewRotationAngle !== 0 && degreesPerStep === 0){ // Object was rotating, now stopped\n                        needsRedraw = true; \n                    }\n                }\n            });\n            if(needsRedraw || objects.some(obj => obj.image && obj.settings.degreesPerFrame === 0)) { \n                drawLivePreview();\n            }\n        }\n        if (objects.some(o => o.image)) { \n            animationFrameId = requestAnimationFrame(animationLoop);\n        } else {\n            animationFrameId = null; \n            drawLivePreview(); // Clear canvas if no images\n        }\n    }\n\n    function startOrUpdateAnimationLoop() {\n        if (animationFrameId) {\n            cancelAnimationFrame(animationFrameId); \n            animationFrameId = null;\n        }\n        if (objects.some(obj => obj.image)) { \n            globalLastFrameTimestamp = performance.now(); \n            animationFrameId = requestAnimationFrame(animationLoop);\n        } else {\n             drawLivePreview(); // Clear canvas if no images\n        }\n    }\n    \n    // Event listeners for per-object settings\n    [degreesPerFrameInput, finalVerticalSizeInput, opacityInput].forEach(input => {\n        input.addEventListener('input', () => saveSettingForActiveObject(input));\n    });\n\n    // Event listeners for global/composite settings\n    [totalExportFramesInput, frameTimeInput, webpCompressionInput].forEach(input => {\n         input.addEventListener('input', () => {\n             if (input === frameTimeInput && objects.some(obj => obj.image)) {\n                 startOrUpdateAnimationLoop(); // Frame time affects live preview speed\n             }\n             // totalExportFrames & webpCompression only affect export, no immediate redraw needed.\n         });\n    });\n    \n    exportButton.addEventListener('click', async () => {\n        // Use the globally available WebP object from the UMD script\n        if (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined') { \n             exportMessage.innerHTML = \"<span class='text-red-500 font-bold'>CRITICAL ERROR: WebP encoding library ('webp-wasm.js' if local, or npm install) not found or failed to load. Animated export is disabled.</span>\";\n             console.error(\"WebP or WebP.Encoder is undefined. Library might not have initialized correctly.\");\n             return;\n        }\n        const activeImages = objects.filter(obj => obj.image);\n        if (activeImages.length === 0) { \n            exportMessage.textContent = \"No images to export.\";\n            return;\n        }\n\n        exportMessage.textContent = \"Preparing animated WebP export...\";\n        loadingIndicator.classList.remove('hidden');\n        exportButton.disabled = true;\n        await new Promise(resolve => setTimeout(resolve, 100)); // Allow UI to update\n\n        try {\n            const compositeTotalFrames = parseInt(totalExportFramesInput.value) || 36;\n            const compositeFrameTimeMs = parseFloat(frameTimeInput.value) || 83.3;\n            const compositeWebpQuality = parseInt(webpCompressionInput.value) || 75; \n\n            if (compositeTotalFrames < 1) { \n                exportMessage.textContent = \"Total export frames must be at least 1.\";\n                loadingIndicator.classList.add('hidden');\n                exportButton.disabled = false;\n                return;\n            }\n            \n            const offscreenCanvas = document.createElement('canvas');\n            // The offscreen canvas for export should be the actual 1600x1600 working resolution\n            offscreenCanvas.width = 1600; \n            offscreenCanvas.height = 1600;\n            const offCtx = offscreenCanvas.getContext('2d');\n            \n            // Initialize WebP Encoder from the global WebP object\n            const webPEncoder = new WebP.Encoder(offscreenCanvas.width, offscreenCanvas.height, {\n                quality: compositeWebpQuality, \n                lossless: false // Set to true for lossless if preferred, false for better compression (lossy)\n            });\n            webPEncoder.setLoops(0); // 0 for infinite loop\n\n            for (let i = 0; i < compositeTotalFrames; i++) {\n                offCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height); \n                // Draw all active objects in REVERSE order for correct layering in export\n                // (Object 0 is top layer, drawn last)\n                for (let k = MAX_OBJECTS - 1; k >= 0; k--) { \n                    const obj = objects[k];\n                    if (!obj.image) continue;\n\n                    const currentRotationDegrees = i * (obj.settings.degreesPerFrame || 0);\n                    let exportObjHeight = obj.settings.finalVerticalSize || obj.originalHeight;\n                    if(exportObjHeight <=0) exportObjHeight = obj.originalHeight;\n                    const aspectRatio = obj.originalWidth > 0 && obj.originalHeight > 0 ? obj.originalWidth / obj.originalHeight : 1;\n                    let exportObjWidth = exportObjHeight * aspectRatio;\n                    \n                    // Scale object to fit within the 1600x1600 export canvas if needed, maintaining aspect ratio\n                    const maxDimExport = 1580; // Similar to preview, with some padding\n                    if (exportObjWidth > maxDimExport || exportObjHeight > maxDimExport) {\n                        if (aspectRatio >= 1) { // Wider or square\n                             exportObjWidth = maxDimExport; exportObjHeight = maxDimExport / aspectRatio; \n                        } else { // Taller\n                             exportObjHeight = maxDimExport; exportObjWidth = maxDimExport * aspectRatio; \n                        }\n                    }\n\n                    offCtx.save();\n                    offCtx.globalAlpha = (obj.settings.opacity / 100); \n                    offCtx.translate(offscreenCanvas.width / 2, offscreenCanvas.height / 2); // Center in 1600x1600\n                    offCtx.rotate(currentRotationDegrees * Math.PI / 180);\n                    offCtx.drawImage(obj.image, -exportObjWidth / 2, -exportObjHeight / 2, exportObjWidth, exportObjHeight);\n                    offCtx.restore(); \n                }\n                offCtx.globalAlpha = 1.0; // Reset globalAlpha for the context before adding frame\n                \n                // Add frame to encoder\n                webPEncoder.addFrame(offCtx, compositeFrameTimeMs);\n                exportMessage.textContent = `Encoding frame ${i + 1} of ${compositeTotalFrames}...`;\n                if (i % 5 === 0 && i > 0) { // Yield to browser to keep UI responsive\n                    await new Promise(resolve => setTimeout(resolve, 0)); \n                }\n            }\n            \n            exportMessage.textContent = \"Finalizing WebP animation...\";\n            await new Promise(resolve => setTimeout(resolve, 50)); // Short delay for UI\n\n            const webpData = webPEncoder.finish(); // Get Uint8Array\n            webPEncoder.release(); // IMPORTANT: Release encoder resources\n\n            const blob = new Blob([webpData], { type: 'image/webp' });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `spinner_animation_${Date.now()}.webp`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url); \n\n            exportMessage.innerHTML = `Animated WebP exported successfully! (${compositeTotalFrames} frames)`;\n            exportMessage.className = \"text-sm text-center text-green-700 mt-2 font-semibold\";\n\n        } catch (error) { \n            console.error(\"Error during WebP export:\", error);\n            exportMessage.textContent = \"Error during WebP export. Check console.\";\n            exportMessage.className = \"text-sm text-center text-red-600 mt-2\";\n        } finally { \n            loadingIndicator.classList.add('hidden');\n            // Re-enable button only if library is loaded and images exist\n            exportButton.disabled = !objects.some(o => o.image) || (typeof WebP === 'undefined' || typeof WebP.Encoder === 'undefined');\n        }\n    });\n\n    // Initialize the application\n    initializeObjectsAndUI();\n    // Initially disable export button until an image is loaded and library is confirmed\n    exportButton.disabled = true; \n});\n"],"names":["document","addEventListener","objects","activeObjectIndex","animationFrameId","globalLastFrameTimestamp","canvas","getElementById","ctx","getContext","canvasMessage","objectSelectorContainer","imageUpload","removeImageButton","degreesPerFrameInput","finalVerticalSizeInput","opacityInput","totalExportFramesInput","frameTimeInput","webpCompressionInput","exportButton","loadingIndicator","exportMessage","createObjectSelectorButtons","innerHTML","forEach","obj","container","createElement","classList","add","button","textContent","name","image","setActiveObject","id","fileNameSpan","fileName","appendChild","updateActiveButtonUI","buttons","querySelectorAll","fileNameSpans","btn","index","toggle","remove","loadSettingsForActiveObject","currentObject","value","settings","degreesPerFrame","finalVerticalSize","opacity","disabled","some","WebP","Encoder","drawLivePreview","clearRect","width","height","hasAnyImage","i","MAX_OBJECTS","previewHeight","originalHeight","aspectRatio","originalWidth","previewWidth","maxDim","save","globalAlpha","boxX","boxY","tempAlpha","strokeStyle","lineWidth","strokeRect","translate","rotate","livePreviewRotationAngle","Math","PI","drawImage","restore","animationLoop","timestamp","desiredFrameTime","parseFloat","elapsed","needsRedraw","degreesPerStep","o","requestAnimationFrame","startOrUpdateAnimationLoop","cancelAnimationFrame","performance","now","console","error","event","file","target","files","type","reader","FileReader","onload","e","Image","findIndex","onerror","src","result","readAsDataURL","input","saveSettingForActiveObject","inputElement","settingKey","isNaN","max","min","activeImages","filter","length","Promise","resolve","setTimeout","compositeTotalFrames","parseInt","compositeFrameTimeMs","compositeWebpQuality","offscreenCanvas","offCtx","webPEncoder","quality","lossless","setLoops","k","currentRotationDegrees","exportObjHeight","exportObjWidth","maxDimExport","addFrame","webpData","finish","release","blob","Blob","url","URL","createObjectURL","a","href","download","Date","body","click","removeChild","revokeObjectURL","className","push"],"version":3,"file":"Spinner-App.5342adde.js.map"}